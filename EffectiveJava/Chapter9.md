# 9장. 일반적인 프로그래밍 원칙

## 아이템 57. 지역변수의 범위를 최소화하라

- 거의 모든 지역변수는 선언과 동시에 초기화해야 하며, 초기화에 필요한 정보가 충분하지 않다면 충분해질 때까지 선언을 미뤄야함
    - try-catch을 사용할 때 변수를 초기화하는 표현식에서 검사 예외를 던질 가능성이 있다면 try 블록 안에서 초기화해야 함 → 그렇지 않다면 예외가 블록을 넘어 메서드에까지 전파됨
- 반복문에서는 반복 변수의 범위를 반복문의 몸체, 그리고 for 키워드와 몸체 사이의 괄호 안으로 제한되므로 반복 변수의 값을 나중에 써야하는 상황이 아니라면 while문 대신 for문을 사용하자
- 메서드를 작게 유지하고 한 가지 기능에 집중하여 지역범위의 범위를 작게할 수 있음

## 아이템 58. 전통적인 for문보다는 for-each문을 사용하라

```java
for(Element e : elements) {}
```

- elements안의 각 원소 e에 대해 반복함

```java
List<Card> deck = new ArrayList<>();
        
for (Iterator<Suit> i = suits.iterator(); i.hasNext(); )
      for (Iterator<Rank> j = ranks.iterator(); j.hasNext(); )
          deck.add(new Card(i.next(), j.next()));
```

- 맨 마지막 줄의 i.next()에는 Suit 하나당 불려야하는데 내부 반복문에서 호출되고 있어 Rank 하나당 불리고 있음 → 두 번째 for 위에 i.next를 저장하는 변수를 두는 방법도 있지만, for-each 문을 중첩하면 다음과 같이 깔끔해짐

```java
for (Suit suit : suits)
      for (Rank rank : ranks)
          deck.add(new Card(suit, rank));
```

- 하지만 for-each문을 사용할 수 없는 상황도 존재함
    1. 파괴적인 필터링: 컬렉션을 순회하면서 선택된 원소를 제거해야 하는 상황
    2. 변형: 리스트나 배열을 순회하며 일부 혹은 전체를 교체해야한다면 반복자나 인덱스가 필요함
    3. 병렬 반복: 여러 컬렉션을 병렬로 순회해야 하는 경우

## 아이템 59. 라이브러리를 익히고 사용하라

- 다음의 라이브러리들은 공부할 필요가 있음
    - `java.lang`, `java.util`, `java.io`, `java.util.concurrent`

## 아이템 60. 정확한 답이 필요하다면 float와 double은 피하라

- float와 double 타입은 과학과 공학 계산용으로 설계되어 금융 관련 계산과는 맞지 않음
- 금융 계산에는 BigDecimal, int 혹은 long을 사용해야함
- BigDecimal?
    - Java에서 숫자를 정밀하게 저장하고 표현할 수 있는 유일한 방법
    - 소수점을 저장할 수 있는 가장 크기가 큰 타입인 double은 소수점의 정밀도에 있어 한계가 있어 값이 유실될 수 있음
    - 단점은 느린 속도와 기본타입보다 불편한 사용법
        
        → 숫자가 너무 크지 않다면 long을 사용하라
        

## 아이템 61. 박싱된 기본 타입보다는 기본 타입을 사용하라

- 기본 타입과 박싱된 기본 타입의 차이점
    - 기본 타입은 값만 가지고 있으나 박싱된 기본 타입은 값에 더해 식별성의 속성을 가짐
        
        → 박싱된 기본 타입의 두 인스턴스는 값이 같아도 ==로 비교시 서로 다르다고 식별될 수 있음
        
    - 박싱된 기본 타입은 유효하지 않은 값, null을 가질 수 있음
    - 기본 타입이 박싱된 기본 타입보다 시간과 메모리 사용면에서 더 효율적임
- 다음과 같은 상황을 주의하라
    
    ```java
    public static void main(String[] args){
    	Long sum = 0L;
    	for (long i = 0; i <= Integer.MAX_VALUE; i++){
    		sum += i;
    	}
    	System.out.println(sum);
    }
    ```
    
    : sum을  박싱된 기본 타입으로 선언하며 sum += i; 에서 박싱과 언박싱이 반복해서 일어나 매우 느려짐
    
- 박싱된 기본 타입은 컬렉션의 원소, 키, 값에 쓰거나 리플렉션을 통해 메서드를 호출할 때는 써야함

## 아이템 62. 다른 타입이 적절하다면 문자열 사용을 피하라

- 코드 62-4 이해안됨

## 아이템 63. 문자열 연결은 느리니 주의하라

- 문자열 연결 연산자로 문자열 n개를 잇는 시간은 n^2에 비례함
    
    → 성능 저하를 피하고 싶다면 String 대신 StringBuilder를 사용하자
    

## 아이템 64. 객체는 인터페이스를 사용해 참조하라

- 객체를 생성할 때 인터페이스를 타입으로 사용하는 업캐스팅을 하자
    
    ```java
    // 좋은 예
    Set<Son> sonSet = new LinkedHashSet<>();
    
    // 나쁜 예
    LinkedHashSet<Son> sonSet = new LinkedHashSet<>();
    ```
    
    → 구현체가 바뀌어도 유연성을 유지하기 쉬워짐
    

## 아이템 65. 리플렉션보다는 인터페이스를 사용하라

- 리플렉션은 Constructor, Method, Field 인스턴스를 이용해 해당 클래스의 인스턴스를 생성하거나, 메서드를 호출하거나, 필드에 접근할 수 있음
- 리플렉션의 단점
    1. 컴파일 타입 검사의 이점을 누릴 수 없음 런타임에야 오류를 알게 될 것
    2. 코드가 지저분해지고 장황해짐
    3. 성능이 떨어짐 리플렉션을 통한 메서드 호출은 상당히 느림