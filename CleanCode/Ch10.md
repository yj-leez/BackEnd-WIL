# Ch10 클래스

### 클래스를 정의하는 표준 자바 관례에 따르면 차례로 클래스 체계가 구성된다

- 변수 목록
    - 정적 공개 상수 `public static final`: 해당 클래스의 모든 인스턴스에서 공유됩니다. 즉, 클래스의 인스턴스를 생성하지 않고도 클래스 이름을 통해 접근 가능
    - 정적 비공개 상수 `private static final`
    - 비공개 인스턴스 변수 `private`: 클래스의 각 인스턴스마다 별도의 값을 가질 수 있으며 해당 클래스의 인스턴스를 통해서만 접근 가능
- 공개 함수
- 비공개 함수는 자신을 호출하는 공개 함수 직후에 넣는다.

→ 추상화 단계가 순차적으로 내려간다.

### 클래스는 작아야 한다

- 함수는 물리적인 행 수로 크기를 측정했지만, 클래스는 **맡은 책임**을 센다.

### 단일 책임 원칙(SRP)

- 클래스나 모듈을 변경할 이유가 단 하나뿐이어야 한다는 원칙
- SuperDashboard에서 버전 정보만을 다루는 메서드 세 개를 따로 빼내 Version이라는 독자적인 클래스를 만드는 것처럼, 만능 클래스를 **단일 책임 클래스 여럿으로 분리**하기 위해 노력하자.
- **클래스 몇 개가 아니라 작은 클래스 여럿으로 이뤄진 시스템이 더 바람직하다.** 아무리 강조해도 부족함이 없다.

### 응집도

- 인스턴스 변수 수가 작아야 한다.
- 클래스 메서드는 클래스 인스턴스 변수를 하나 이상 사용해야 한다.
- 클래스 메서드가 변수, 인스턴스 변수를 많이 사용할 수록 응집도가 높다.
- 아래 Stack을 구현한 코드는 응집도가 아주 높다. size()를 제외한 두 메서드는 두 변수를 모두 사용하기 때문이다.

```java
public class Stack{
	private int topOfStack = 0;
	List<Integer> elements = new LinkedList<Integer>();
	
	public int size(){
		return topOfSize;
	}
	
	public void push(int element){
		topOfStack++;
		elements.add(element);
	}
	
	public int pop() throws PoppedWhenEmpty{
		if(topOfStack == 0)
			throw new PoppedWhenEmpty();
		int element = elements.get(--topOfSize);
		elements.remove(topOfStack);
		return element;
	}
}
```

- 사실 큰 함수를 작은 함수 여럿으로 나누기만 해도 클래스 수가 많아진다. 함수를 분리할 때 기존 함수의 변수가 여럿 필요하다면 새 함수에 인수로 다 넘기기 보다 클래스 인스턴스 변수로 승격하면 된다.
    
    이렇게 된다면 몇몇 함수만 사용하는 인스턴스 변수가 늘어나고, 그렇다면 독자적인 클래스로 분리함으로써 응집도를 높일 수 있다.
    

### 변경하기 쉬운 클래스

- 새 기능을 수정하거나 기존 기능을 변경할 때 건드를 코드가 최소인 시스템 구조가 바람직하다.
- 이상적인 시스템이라면 새 기능을 추가할 때 시스템을 확장할 뿐 기존 코드를 변경하지는 않는다.

### 변경으로부터 격리

- 상세한 구현에 의존하는 코드는 테스트도 어렵다. 계속해서 값이 바뀌는 외부 API를 사용한다고 가정한다면, 값이 계속 바뀌기 때문에 테스트 코드를 작성하기 어렵다.
    
    이럴 때는 테스트가 가능할 정도로 시스템의 결합도를 낮춰 유연성과 재사용성을 높이면 된다.